/*
Mein fibonacci Code aus P2 A1 zum testen:
    final int n = 5; int a = 0, b = 1, c = 0, index = 1; { while index < n{ c = b + a; a = b; b = c; index = index + 1; } print(b); }
Code mit Zuweisungen drin:
    final int c = 1; int v = 2; v = 3;
Code mit Zuweisungen und Statementblöcke drin:
    final int c = 1; int v = 2; { v = 3; print(v);}
Code mit Zuweisungen, Statementblöcke und if
    final int c = 1; int v = 2; { if v == 2 print(c); }
Code mit Zuweisungen, Statementblöcke und if else
    final int c = 1; int v = 2; { if v == 2 print(1); else print(2); }
Code mit Zuweisungen, Statementblöcke, if else und while
    final int c = 1; int v = 2; { while v == 2 { print(1); print(2);} }
*/


//PARSER FÜR MINIJAVA
PARSER_BEGIN(P5)
	public class P5 {
        //Erstellt die SymbolTabelle und übergibt sie dem CodeGenberator
        private static Compiler.SymbolTable symbolTable = new Compiler.SymbolTable();
        private static Compiler.Compiler compiler = new Compiler.Compiler(symbolTable);
        //TODO: mach hier ein neues statisches Method ArrayList, wodrin die Method objekte gespeichert werden

		public static void main (String args []) {
			P5 parser = new P5(System.in);
            String main = "";
			try {
				main = parser.start();
			} catch (ParseException e) {
				System.err.println(e);
			}

            /*
            JAVA DOC FÜR METHODOBJECT, WEIL DAS HIER NICHT LÄDT:
            Hat drei Variablen name, argsSize und byteCode
            - name natürlich der Name der Methode, zb main unten
            - argsSize eben die Anzahl der Parameter, zb main hat ja nur einen, das String[] args
            - bytecode eben ein String welcher den Bytecode enthält, zb unten für die main packe ich das in den String main
            => METHODOBJECT KLASSE HAT AUCH GETTER UND SETTER FÜR DIESE VARIABLEN
             */
             //TODO: hier muss für jedes Method objekt aus der ArrayList oben ein MethodObject erstellt werden du weißt

            JavaClassFileGenerator.MethodObject mainMethod = new JavaClassFileGenerator.MethodObject("main", 1, main);

            //Stell hier die false auf true wenn ich eine lesbare Klasse haben will, zum Debuggen oder so
            JavaClassFileGenerator.JavaClassFileGenerator classGenerator = new JavaClassFileGenerator.JavaClassFileGenerator("myClass", true, false, false);
            classGenerator.generateClassFile(mainMethod);
		}
	}
PARSER_END(P5)

SKIP:
{
  " " | "\t" | "\n" | "\r"
}

TOKEN :
{
  <FINAL : "final">
| <INT : "int">
| <PRINT : "print">
| <IF : "if">
| <WHILE : "while">
| <ELSE : "else">
| <VOID : "void">
| <RETURN : "return">
| <COMPOP : "!=" | "==" | "<=" | ">=" | ">" | "<">
| <NUMBER : ("0" | ["1"-"9"] (["0"-"9"])*)>
| <IDENT : (["a"-"z"] (["a"-"z"] | ["A"-"Z"] | ["0"-"9"])*)>
}

String PROGRAM():
{String varDecl, statement;}
{
    CONSTDECL()
    varDecl = VARDECL()
    //TODO: HIER WEITERMACHEN
    (PROCEDURE())*
    (FUNCTION())*
    statement = STATEMENT()
    { return varDecl + statement; }
}

//Code zu Konstanten ist der gleiche wie in P3
void CONSTDECL() :
{}
{
    (<FINAL> <INT> CONSTZUW() CONSTLIST() ";")?
}

void CONSTZUW():
{ String constName; }
{
    <IDENT>
    { constName = token.image; }
    "="
    <NUMBER>
    {
        symbolTable.addConstant(constName, token.image);
    }
}

void CONSTLIST():
{}
{
    ("," CONSTZUW())*
}

String VARDECL():
{String varDecl = "";}
{
    (
        <INT>
        { varDecl = VARZUW() + VARLIST(); }
        ";"
    )?
   { return varDecl; }
}

String VARZUW():
{ String varName, result = ""; }
{
    <IDENT>
    {
        //fügt die Variable in die Hashtable ein und speichert sich den Index
        varName = token.image;
        result = compiler.declareVariable(varName);
    }
    (
        "=" <NUMBER>
        {
            //Falls variable doch initialisiert wird, dann erstelle hier den passenden code
            result = compiler.initVariable(varName, token.image);
        }
    )?
    { return result; }
}

String VARLIST():
{String varDecl = "";}
{
    (
        ","
        { varDecl = varDecl + VARZUW(); }
    )*
    { return varDecl; }
}

//TODO: HIER AUF STRING UMSTELLEN UND RETURN WENN ICH UMGESETZT HABE
void PROCEDURE():
{}
{
    <VOID>
    <IDENT>
    "("
    //TODO: HIER WEITERMACHEN
    (ROUTINENPARAMETER())?
    ")"
    "{"
    //TODO: HIER WEITERMACHEN
    (ROUTINENBLOCK())?
    "}"
}

//TODO: HIER AUF STRING UMSTELLEN UND RETURN WENN ICH UMGESETZT HABE
void FUNCTION():
{}
{
    <VOID>
    <IDENT>
    "("
    //TODO: HIER WEITERMACHEN
    (ROUTINENPARAMETER())?
    ")"
    "{"
    //TODO: HIER WEITERMACHEN
    (ROUTINENBLOCK())?
    <RETURN>
    EXPRESSION()
    ";"
    "}"
}

//TODO: HIER AUF STRING UMSTELLEN UND RETURN WENN ICH UMGESETZT HABE
void ROUTINENPARAMETER():
{}
{
    //TODO: HIER WEITERMACHEN
    <INT> <IDENT> ROUTINENPARAMETER_LIST()
}

//TODO: HIER AUF STRING UMSTELLEN UND RETURN WENN ICH UMGESETZT HABE
void ROUTINENPARAMETER_LIST():
{}
{
    //TODO: HIER WEITERMACHEN
    (
        "," <INT> <IDENT> ROUTINENPARAMETER_LIST()
    )?
}

//TODO: HIER AUF STRING UMSTELLEN UND RETURN WENN ICH UMGESETZT HABE
void ROUTINENBLOCK():
{}
{
    //TODO: HIER WEITERMACHEN
    //Das wird hier nicht mit ? gemacht weil CONSTDECL selber schon optional ist, wurde für LLk verbessert du weißt
    CONSTDECL()
    VARDECL()
    STATEMENT()
}

String EXPRESSION():
{ String term, summe; }
{
    term = TERM()
    //term wird hier SUMME übergeben, damit der linke Operand in der Methode auch zugänglich ist
    summe = SUMME(term)
    { return summe; }
}

//Codeerzeugung genau wie Postfixtrafo aus P3
String SUMME(String term):
{ String left, right, op = null; }
{
    { left = term; }
    (
        ("+" | "-")
        { op = token.image; }
        right = TERM()
        {
            //60 für Addition, 64 für Multiplikation
            if(op.equals("+")){
                left = left + right + "60 ";
            } else{
                left = left + right + "64 ";
            }
        }
    )*
    { return left; }
}

String TERM():
{ String faktor, product; }
{
    faktor = FAKTOR()
    product = PRODUCT(faktor)
    { return product; }
}

String PRODUCT(String faktor):
{ String left, right, op = null; }
{
    { left = faktor; }
    (
        ("*" | "/")
        { op = token.image; }
        right = TERM()
        {
            if(op.equals("*")){
                left = left + right + "68 ";
            } else{
                left = left + right + "6c ";
            }
        }
    )*
    { return left; }
}

String FAKTOR():
{ String number, expression; }
{
    <NUMBER>
    {
        //im Falle einer Zahl die Zahl einfach alls Hexwert zurückgeben
        number = token.image;
        return "10 " + String.format("%02x", Integer.parseInt(number)) + " ";
    }
    |
    //TODO: HIER WEITERMACHEN
    <IDENT> (FUNCTIONCALL())?
    {
        return compiler.generateIdentCode(token.image);
    }
    |
    "(" expression = EXPRESSION() ")" { return expression; }
}

String CONDITION():
{String left = "", right = "", compOP = "";}
{
    left = EXPRESSION()
    <COMPOP> {compOP = token.image;}
    right = EXPRESSION()
    { return compiler.generateConditionCode(left, right, compOP);}
}



/*TODO: WENN ES HIER FAXEN GIBT DANN ÄNDER UM IN LLk, ALSO
   FUNCTIONCALL = "(" (EXPRESSION FUNCTIONCALL_LIST)? ")"
   FUNCTIONCALL_LIST = , EXPRESSION FUNCTIONCALL_LIST | eps
   * */
//TODO: HIER AUF STRING UMSTELLEN UND RETURN WENN ICH UMGESETZT HABE
void FUNCTIONCALL():
{}
{
    //TODO: HIER WEITERMACHEN
    "("
        (
            EXPRESSION()
            (
                "," EXPRESSION()
            )*
        )?
    ")"
}

/*TODO: WENN ES HIER FAXEN GIBT DANN ÄNDER UM IN LLk, ALSO
   FUNCTIONCALL = "(" (EXPRESSION FUNCTIONCALL_LIST)? ")"
   FUNCTIONCALL_LIST = , EXPRESSION FUNCTIONCALL_LIST | eps
   * */
//TODO: HIER AUF STRING UMSTELLEN UND RETURN WENN ICH UMGESETZT HABE
void PROCCALL():
{}
{
    //TODO: HIER WEITERMACHEN
    "("
        (
            EXPRESSION()
            (
                "," EXPRESSION()
            )*
        )?
    ")"
}

String STATEMENT():
{String expression = "", ident = "", statement = "", condition = "", optElse = "";}
{
    <IDENT>
    { ident = token.image;}
    (
        "="
        expression = EXPRESSION()
        { return expression + "36 " + symbolTable.getVariable(ident) + " "; }

        |

        //TODO: HIER WEITERMACHEN
        PROCCALL()
    )
    ";"

    |

    <PRINT> "(" expression = EXPRESSION() ")" ";"
    { return expression + "b8 (print) "; }

    |

    "{" statement = STMTLIST() "}"
    { return statement; }

    |

    <IF>
    condition = CONDITION()
    statement = STATEMENT()
    optElse = OPTELSE()
    { return compiler.generateIfCode(condition, statement, optElse); }

    |

    <WHILE>
    condition = CONDITION()
    statement = STATEMENT()
    { return compiler.generateWhileCode(condition, statement); }
}

String OPTELSE():
{String statement = "";}
{
    (
    <ELSE>
    statement = STATEMENT()
    {return statement;}
    )?
    {return "";}
}

String STMTLIST():
{String statement = "", singleStatement = "";}
{
    (
     singleStatement = STATEMENT()
     {statement = statement + singleStatement;}
    )*
    {return statement;}
}

String start():
{ String result; }
{
    result = PROGRAM()
    <EOF> { return compiler.resolveLabels(result + "b1 "); }

}

/*
Mein fibonacci Code aus P2 A1 zum testen:
    final int n = 5; int a = 0, b = 1, c = 0, index = 1; { while index < n{ c = b + a; a = b; b = c; index = index + 1; } print(b); }
Code mit Zuweisungen drin:
    final int c = 1; int v = 2; v = 3;
Code mit Zuweisungen und Statementblöcke drin:
    final int c = 1; int v = 2; { v = 3; print(v);}
Code mit Zuweisungen, Statementblöcke und if
    final int c = 1; int v = 2; { if v == 2 print(c); }
Code mit Zuweisungen, Statementblöcke und if else
    final int c = 1; int v = 2; { if v == 2 print(1); else print(2); }
Code mit Zuweisungen, Statementblöcke, if else und while
    final int c = 1; int v = 2; { while v == 2 { print(1); print(2);} }
Code mit ALLEM drin, etwas komplexer
    {while 1 > 1 {if 1 < 1 print(1); else print(2);}}
*/