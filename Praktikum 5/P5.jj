/* Mein fibonacci Code aus P2 A1 zum testen:
final int n = 5; int a = 0, b = 1, c = 0, index = 1; { while index < n{ c = b + a; a = b; b = c; index = index + 1; } print(b); }
Fürs erste noch den MiniJavaExp Code aus P4: final int c = 1; int v = 2; print(c+v*v*v);
*/


//PARSER FÜR MINIJAVA
PARSER_BEGIN(P5)
	public class P5 {
        //Erstellt die SymbolTabelle und übergibt sie dem CodeGenberator
        private static CodeGeneration.SymbolTable symbolTable = new CodeGeneration.SymbolTable();
        private static CodeGeneration.CodeGenerator codeGenerator = new CodeGeneration.CodeGenerator(symbolTable);

		public static void main (String args []) {
			P5 parser = new P5(System.in);
            String result = "";
			try {
                //Hier Parser starten und Ergebnis ausgeben
				result = parser.start();
                System.out.println(result);
			} catch (ParseException e) {
				System.err.println(e);
			}
            JavaClassFileGenerator.MethodObject mainMethod = new JavaClassFileGenerator.MethodObject("main", 1, result);
            JavaClassFileGenerator.JavaClassFileGenerator classGenerator = new JavaClassFileGenerator.JavaClassFileGenerator("myClass", true, true, true);
            classGenerator.generateClassFile(mainMethod);
		}
	}
PARSER_END(P5)

SKIP:
{
  " " | "\t" | "\n" | "\r"
}

TOKEN :
{
  <FINAL : "final">
| <INT : "int">
| <PRINT : "print">
| <IF : "if">
| <WHILE : "while">
| <ELSE : "else">
| <COMPOP : "!=" | "==" | "<=" | ">=" | ">" | "<">
| <NUMBER : ("0" | ["1"-"9"] (["0"-"9"])*)>
| <IDENT : (["a"-"z"] (["a"-"z"] | ["A"-"Z"] | ["0"-"9"])*)>
}

String PROGRAM():
{String varDecl, statement;}
{
    CONSTDECL()
    varDecl = VARDECL()
    statement = STATEMENT()
    { return varDecl + statement; }
}

//Code zu Konstanten ist der gleiche wie in P3
void CONSTDECL() :
{}
{
    (<FINAL> <INT> CONSTZUW() CONSTLIST() ";")?
}

void CONSTZUW():
{ String constName; }
{
    <IDENT>
    { constName = token.image; }
    "="
    <NUMBER>
    {
        symbolTable.addConstant(constName, token.image);
    }
}

void CONSTLIST():
{}
{
    ("," CONSTZUW())*
}

String VARDECL():
{String varDecl = "";}
{
    (
        <INT>
        { varDecl = VARZUW() + VARLIST(); }
        ";"
    )?
   { return varDecl; }
}

String VARZUW():
{ String varName, result = ""; }
{
    <IDENT>
    {
        //fügt die Variable in die Hashtable ein und speichert sich den Index
        varName = token.image;
        result = codeGenerator.declareVariable(varName);
    }
    (
        "=" <NUMBER>
        {
            //Falls variable doch initialisiert wird, dann erstelle hier den passenden code
            result = codeGenerator.initVariable(varName, token.image);
        }
    )?
    { return result; }
}

String VARLIST():
{String varDecl = "";}
{
    (
        ","
        { varDecl = varDecl + VARZUW(); }
    )*
    { return varDecl; }
}

String EXPRESSION():
{ String term, summe; }
{
    term = TERM()
    //term wird hier SUMME übergeben, damit der linke Operand in der Methode auch zugänglich ist
    summe = SUMME(term)
    { return summe; }
}

//Codeerzeugung genau wie Postfixtrafo aus P3
String SUMME(String term):
{ String left, right, op = null; }
{
    { left = term; }
    (
        ("+" | "-")
        { op = token.image; }
        right = TERM()
        {
            //60 für Addition, 64 für Multiplikation
            if(op.equals("+")){
                left = left + right + "60 ";
            } else{
                left = left + right + "64 ";
            }
        }
    )*
    { return left; }
}

String TERM():
{ String faktor, product; }
{
    faktor = FAKTOR()
    product = PRODUCT(faktor)
    { return product; }
}

String PRODUCT(String faktor):
{ String left, right, op = null; }
{
    { left = faktor; }
    (
        ("*" | "/")
        { op = token.image; }
        right = TERM()
        {
            if(op.equals("*")){
                left = left + right + "68 ";
            } else{
                left = left + right + "6c ";
            }
        }
    )*
    { return left; }
}

String FAKTOR():
{ String number, expression; }
{
    <NUMBER>
    {
        //im Falle einer Zahl die Zahl einfach alls Hexwert zurückgeben
        number = token.image;
        return String.format("%02x", Integer.parseInt(number)) + " ";
    }
    |
    <IDENT>
    {
        return codeGenerator.generateIdentCode(token.image);
    }
    |
    "(" expression = EXPRESSION() ")" { return expression; }
}

void CONDITION():
{}
{
    EXPRESSION() <COMPOP> EXPRESSION()
}

String STATEMENT():
{String expression;}
{
    <IDENT> "=" EXPRESSION() ";"
    { return ""; }
    |
    <PRINT> "(" expression = EXPRESSION() ")" ";"
    //b8 print für den print-Befehl und b1 für return
    { return ""; }
    |
    "{" STMTLIST() "}"
    { return ""; }
    |
    <IF> CONDITION() STATEMENT() OPTELSE()
    { return ""; }
    |
    <WHILE> CONDITION() STATEMENT()
    { return ""; }
}

void OPTELSE():
{}
{
    (<ELSE> STATEMENT())?
}

//TODO: DAS KANN MAN SICH EVTL MIT EINEM KLEENE STERN BEI STATEMENT SPAREN IDK
void STMTLIST():
{}
{
    (STATEMENT())*
}

String start():
{ String result; }
{
    result = PROGRAM()
    <EOF> { return result; }
}

/* Mein fibonacci Code aus P2 A1 zum testen:
final int n = 5; int a = 0, b = 1, c = 0, index = 1; { while index < n{ c = b + a; a = b; b = c; index = index + 1; } print(b); }
Fürs erste noch den MiniJavaExp Code aus P4: final int c = 1; int v = 2; print(c+v*v*v);
*/