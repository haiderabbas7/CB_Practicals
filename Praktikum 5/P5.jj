/*
Mein fibonacci Code aus P2 A1 zum testen:
    final int n = 5; int a = 0, b = 1, c = 0, index = 1; { while index < n{ c = b + a; a = b; b = c; index = index + 1; } print(b); }
Code mit Zuweisungen drin:
    final int c = 1; int v = 2; v = 3;
Code mit Zuweisungen und Statementblöcke drin:
    final int c = 1; int v = 2; { v = 3; print(v);}
Code mit Zuweisungen, Statementblöcke und if
    final int c = 1; int v = 2; { if v == 2 print(c); }
Code mit Zuweisungen, Statementblöcke und if else
    final int c = 1; int v = 2; { if v == 2 print(1); else print(2); }
Code mit Zuweisungen, Statementblöcke, if else und while
    final int c = 1; int v = 2; { while v == 2 { print(1); print(2);} }
*/


//PARSER FÜR MINIJAVA
PARSER_BEGIN(P5)
    import java.util.ArrayList;
    import Compiler.*;

    public class P5 {
        //Erstellt die SymbolTabelle und übergibt sie dem CodeGenberator
        private static Compiler compiler = new Compiler();
        //TODO: DAS MACHT FAXEN WENN ICH NUR <> SCHREIBE AM ENDE. KANN VLLT NOCH MEHR FAXEN MACHEN, PACK SONST DIE GANZE METHOD KACKE IN COMPILER KLASSE
        private static ArrayList<Method> methods = new ArrayList<Method>();

	    public static void main (String args []) {
		    P5 parser = new P5(System.in);
               String main = "";
		    try {
		    	main = parser.start();
		    } catch (ParseException e) {
		    	System.err.println(e);
		    }

            /*
            JAVA DOC FÜR METHODOBJECT, WEIL DAS HIER NICHT LÄDT:
            Hat drei Variablen name, argsSize und byteCode
            - name natürlich der Name der Methode, zb main unten
            - argsSize eben die Anzahl der Parameter, zb main hat ja nur einen, das String[] args
            - bytecode eben ein String welcher den Bytecode enthält, zb unten für die main packe ich das in den String main
            => METHODOBJECT KLASSE HAT AUCH GETTER UND SETTER FÜR DIESE VARIABLEN
             */
             //TODO: hier muss für jedes Method objekt aus der ArrayList oben ein MethodObject erstellt werden du weißt

            JavaClassFileGenerator.MethodObject mainMethod = new JavaClassFileGenerator.MethodObject("main", 1, main);

            //Stell hier die false auf true wenn ich eine lesbare Klasse haben will, zum Debuggen oder so
            JavaClassFileGenerator.JavaClassFileGenerator classGenerator = new JavaClassFileGenerator.JavaClassFileGenerator("myClass", true, false, false);
            classGenerator.generateClassFile(mainMethod);
	    }
    }
PARSER_END(P5)

SKIP:
{
  " " | "\t" | "\n" | "\r"
}

TOKEN :
{
  <FINAL : "final">
| <INT : "int">
| <PRINT : "print">
| <IF : "if">
| <WHILE : "while">
| <ELSE : "else">
| <VOID : "void">
| <RETURN : "return">
| <COMPOP : "!=" | "==" | "<=" | ">=" | ">" | "<">
| <NUMBER : ("0" | ["1"-"9"] (["0"-"9"])*)>
| <IDENT : (["a"-"z"] (["a"-"z"] | ["A"-"Z"] | ["0"-"9"])*)>
}

String PROGRAM():
{ String varDecl, statement; }
{
    CONSTDECL("main")
    varDecl = VARDECL("main")
    //TODO: EVTL HIER UMÄNDERN, WENN ICH PROCEDURE/FUNCTION UNTEN NACH LLK GEMACHT HAB
    (PROCEDURE())*
    (FUNCTION())*
    statement = STATEMENT("main")
    { return varDecl + statement; }
}

void CONSTDECL(String scope) :
{}
{
    (<FINAL> <INT> CONSTZUW(scope) CONSTLIST(scope) ";")?
}

void CONSTZUW(String scope):
{ String constName; }
{
    <IDENT>
    { constName = token.image; }
    "="
    <NUMBER>
    {
        compiler.addConstant(scope, constName, token.image);
    }
}

void CONSTLIST(String scope):
{}
{
    ("," CONSTZUW(scope))*
}

String VARDECL(String scope):
{String varDecl = "";}
{
    (
        <INT>
        { varDecl = VARZUW(scope) + VARLIST(scope); }
        ";"
    )?
   { return varDecl; }
}

String VARZUW(String scope):
{ String varName, result = ""; }
{
    <IDENT>
    {
        //fügt die Variable in die Hashtable ein und speichert sich den Index
        varName = token.image;
        result = compiler.declareVariable(scope, varName);
    }
    (
        "=" <NUMBER>
        {
            //Falls variable doch initialisiert wird, dann erstelle hier den passenden code
            result = compiler.initVariable(scope, varName, token.image);
        }
    )?
    { return result; }
}

String VARLIST(String scope):
{String varDecl = "";}
{
    (
        ","
        { varDecl = varDecl + VARZUW(scope); }
    )*
    { return varDecl; }
}

/*TODO: WENN ES HIER FAXEN GIBT DANN ÄNDER UM IN LLk
   HALT PROCEDURE_LIST UND SO KACKE
   * */
//TODO: HIER AUF STRING UMSTELLEN UND RETURN WENN ICH UMGESETZT HABE
void PROCEDURE():
{String scope, routinenparameter = "", routinenblock = "";}
{
    <VOID>
    <IDENT>
    {scope = token.image;}
    "(" (routinenparameter = ROUTINENPARAMETER(scope))? ")"
    "{"
        (routinenblock = ROUTINENBLOCK(scope))?
    "}"
    //Er erstellt über den Compiler ein neues Method Objekt der Prozedur und fügt es der ArrayList hinzu
    { methods.add(compiler.createProcedure(routinenparameter, routinenblock));}
}

/*TODO: WENN ES HIER FAXEN GIBT DANN ÄNDER UM IN LLk
   HALT FUNCTION_LIST UND SO KACKE
   * */
//TODO: HIER AUF STRING UMSTELLEN UND RETURN WENN ICH UMGESETZT HABE
void FUNCTION():
{String scope, routinenparameter = "", routinenblock = "";}
{
    <VOID>
    <IDENT>
    {scope = token.image;}
    "(" (routinenparameter = ROUTINENPARAMETER(scope))? ")"
    "{"
    //TODO: HIER WEITERMACHEN
        (routinenblock = ROUTINENBLOCK(scope))?
        <RETURN> EXPRESSION() ";"
    "}"
}

String ROUTINENPARAMETER(String scope):
{String routinenparameter = "";}
{
    //TODO: HIER WEITERMACHEN
    <INT> <IDENT> ROUTINENPARAMETER_LIST(scope)
    {return "";}
}

String ROUTINENPARAMETER_LIST(String scope):
{}
{
    //TODO: HIER WEITERMACHEN
    (
        "," <INT> <IDENT> ROUTINENPARAMETER_LIST(scope)
    )?
    {return "";}
}

String ROUTINENBLOCK(String scope):
{String varDecl, statement;}
{
    //Das wird hier nicht mit ? gemacht weil CONSTDECL selber schon optional ist, wurde für LLk verbessert du weißt
    CONSTDECL(scope)
    varDecl = VARDECL(scope)
    statement = STATEMENT(scope)
    {return varDecl + statement;}
}

String EXPRESSION():
{ String term, summe; }
{
    term = TERM()
    //term wird hier SUMME übergeben, damit der linke Operand in der Methode auch zugänglich ist
    summe = SUMME(term)
    { return summe; }
}

//Codeerzeugung genau wie Postfixtrafo aus P3
String SUMME(String term):
{ String left, right, op = null; }
{
    { left = term; }
    (
        ("+" | "-")
        { op = token.image; }
        right = TERM()
        {
            //60 für Addition, 64 für Multiplikation
            if(op.equals("+")){
                left = left + right + "60 ";
            } else{
                left = left + right + "64 ";
            }
        }
    )*
    { return left; }
}

String TERM():
{ String faktor, product; }
{
    faktor = FAKTOR()
    product = PRODUCT(faktor)
    { return product; }
}

String PRODUCT(String faktor):
{ String left, right, op = null; }
{
    { left = faktor; }
    (
        ("*" | "/")
        { op = token.image; }
        right = TERM()
        {
            if(op.equals("*")){
                left = left + right + "68 ";
            } else{
                left = left + right + "6c ";
            }
        }
    )*
    { return left; }
}

String FAKTOR():
{ String number, expression; }
{
    <NUMBER>
    {
        //im Falle einer Zahl die Zahl einfach alls Hexwert zurückgeben
        number = token.image;
        return "10 " + String.format("%02x", Integer.parseInt(number)) + " ";
    }
    |
    //TODO: HIER WEITERMACHEN
    <IDENT> (FUNCTIONCALL())?
    {
        return compiler.generateIdentCode(token.image);
    }
    |
    "(" expression = EXPRESSION() ")" { return expression; }
}

String CONDITION():
{String left = "", right = "", compOP = "";}
{
    left = EXPRESSION()
    <COMPOP> {compOP = token.image;}
    right = EXPRESSION()
    { return compiler.generateConditionCode(left, right, compOP);}
}



/*TODO: WENN ES HIER FAXEN GIBT DANN ÄNDER UM IN LLk, ALSO
   FUNCTIONCALL = "(" (EXPRESSION FUNCTIONCALL_LIST)? ")"
   FUNCTIONCALL_LIST = , EXPRESSION FUNCTIONCALL_LIST | eps
   * */
//TODO: HIER AUF STRING UMSTELLEN UND RETURN WENN ICH UMGESETZT HABE
void FUNCTIONCALL():
{}
{
    //TODO: HIER WEITERMACHEN
    "("
        (
            EXPRESSION()
            (
                "," EXPRESSION()
            )*
        )?
    ")"
}

/*TODO: WENN ES HIER FAXEN GIBT DANN ÄNDER UM IN LLk, ALSO
   FUNCTIONCALL = "(" (EXPRESSION FUNCTIONCALL_LIST)? ")"
   FUNCTIONCALL_LIST = , EXPRESSION FUNCTIONCALL_LIST | eps
   * */
//TODO: HIER AUF STRING UMSTELLEN UND RETURN WENN ICH UMGESETZT HABE
void PROCCALL():
{}
{
    //TODO: HIER WEITERMACHEN
    "("
        (
            EXPRESSION()
            (
                "," EXPRESSION()
            )*
        )?
    ")"
}

String STATEMENT(String scope):
{String expression = "", ident = "", statement = "", condition = "", optElse = "";}
{
    <IDENT>
    { ident = token.image;}
    (
        "="
        expression = EXPRESSION()
        { return expression + "36 " +  compiler.getVariable(scope, ident) + " "; }

        |

        //TODO: HIER WEITERMACHEN
        PROCCALL()
    )
    ";"

    |

    <PRINT> "(" expression = EXPRESSION() ")" ";"
    { return expression + "b8 (print) "; }

    |

    "{" statement = STMTLIST(scope) "}"
    { return statement; }

    |

    <IF>
    condition = CONDITION()
    statement = STATEMENT(scope)
    optElse = OPTELSE(scope)
    { return compiler.generateIfCode(condition, statement, optElse); }

    |

    <WHILE>
    condition = CONDITION()
    statement = STATEMENT(scope)
    { return compiler.generateWhileCode(condition, statement); }
}

String OPTELSE(String scope):
{String statement = "";}
{
    (
    <ELSE>
    statement = STATEMENT(scope)
    {return statement;}
    )?
    {return "";}
}

String STMTLIST(String scope):
{String statement = "", singleStatement = "";}
{
    (
     singleStatement = STATEMENT(scope)
     {statement = statement + singleStatement;}
    )*
    {return statement;}
}

String start():
{ String result; }
{
    result = PROGRAM()
    <EOF> { return compiler.resolveLabels(result + "b1 "); }

}

/*
Mein fibonacci Code aus P2 A1 zum testen:
    final int n = 5; int a = 0, b = 1, c = 0, index = 1; { while index < n{ c = b + a; a = b; b = c; index = index + 1; } print(b); }
Code mit Zuweisungen drin:
    final int c = 1; int v = 2; v = 3;
Code mit Zuweisungen und Statementblöcke drin:
    final int c = 1; int v = 2; { v = 3; print(v);}
Code mit Zuweisungen, Statementblöcke und if
    final int c = 1; int v = 2; { if v == 2 print(c); }
Code mit Zuweisungen, Statementblöcke und if else
    final int c = 1; int v = 2; { if v == 2 print(1); else print(2); }
Code mit Zuweisungen, Statementblöcke, if else und while
    final int c = 1; int v = 2; { while v == 2 { print(1); print(2);} }
Code mit ALLEM drin, etwas komplexer
    {while 1 > 1 {if 1 < 1 print(1); else print(2);}}
*/